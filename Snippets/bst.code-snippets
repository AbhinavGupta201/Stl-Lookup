{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Binary Search Tree": {
		"scope": "cpp",
		"prefix": "bst",
		"body": [
			"// here item is int datatype. Change it accordingly",
			"typedef int item;",
			"",
			"// node for the BST",
			"struct node",
			"{",
			"    // Data storage",
			"    item data;",
			"    node *left;",
			"    node *right;",
			"    ",
			"    // constructor",
			"    node(int x, node *l=NULL, node *r=NULL){",
			"        data=x;",
			"        left=l;",
			"        right=r;",
			"    }",
			"};",
			" ",
			"struct BST",
			"{",
			"    node *root=NULL; // root of the node",
			"",
			"    // insert function ",
			"    void insert(int x){",
			"        node *n=new node(x);",
			"        if(root==NULL)",
			"        {",
			"            root=n;",
			"            return ;",
			"        }",
			"        node *temp;",
			"        temp=root;",
			"        while(temp){",
			"            if(x < temp->data){",
			"                if(temp->left==NULL)",
			"                    temp->left=n;",
			"                temp=temp->left;",
			"            }",
			"            else if(x > temp->data){",
			"                if(temp->right==NULL)",
			"                    temp->right=n;",
			"                temp=temp->right;",
			"            }",
			"            else ",
			"                return ;",
			"        }",
			"    }",
			"",
			"    // find(): return the reference to the position else NULL",
			"    node* find(node *root,int x){",
			"        if(root){",
			"            if(root->data<x)",
			"                return find(root->right,x);",
			"            else if(root->data>x)",
			"                return find(root->left,x);",
			"            else ",
			"                return root;",
			"            ",
			"        }",
			"        return NULL;",
			"    }",
			"",
			"    node* find(int data){",
			"        return find(root, data);",
			"    }",
			"",
			"    // preorder traversal",
			"    void preorder(node *root){",
			"        if(root){",
			"            cout<<root->data<<\" \";",
			"            preorder(root->left);",
			"            preorder(root->right);",
			"        }",
			"    }",
			"",
			"    // Inorder traversal",
			"    void inorder(node *root){",
			"        if(root){",
			"            inorder(root->left);",
			"            cout<<root->data<<\" \";",
			"            inorder(root->right);",
			"        }",
			"    }",
			"",
			"    // postorder traversal",
			"    void postorder(node *root){",
			"        if(root){",
			"            postorder(root->left);",
			"            postorder(root->right);",
			"            cout<<root->data<<\" \";",
			"        }",
			"    }",
			"",
			"    // level order traversal ",
			"    void levelorder(node *root){",
			"        queue<node*>q;",
			"        if(root!=NULL)",
			"            q.push(root);",
			"        while (q.size()!=0)",
			"        {",
			"            root=q.front();",
			"            q.pop();",
			"            cout<<root->data<<\" \";",
			"            if(root->left)",
			"                q.push(root->left);",
			"            if(root->right)",
			"                q.push(root->right);",
			"        }",
			"        ",
			"    }",
			"",
			"    void preorder(){",
			"        preorder(root);",
			"    }",
			"",
			"    void postorder(){",
			"        postorder(root);",
			"    }",
			"",
			"    void inorder(){",
			"        inorder(root);",
			"    }",
			"",
			"    void levelorder(){",
			"        levelorder(root);",
			"    }",
			"",
			"    // delete the node",
			"    node* delete_node(node *root, int x){",
			"        if(root->data > x){",
			"            root->left=delete_node(root->left,x);",
			"        }",
			"        else if(root->data < x){",
			"            root->right=delete_node(root->right,x);",
			"        }",
			"        else{",
			"            // element is found to be deleted ",
			"            if(root->left==NULL && root->right==NULL)",
			"            {",
			"                return NULL;",
			"            }",
			"            if(root->left==NULL )",
			"            {",
			"                node *temp;",
			"                temp=root->right;",
			"                while(temp->left!=NULL)",
			"                {",
			"                    temp=temp->left;",
			"                }",
			"                x=temp->data;",
			"                root->data=x;",
			"                root->right=delete_node(root->right,x);",
			"            }",
			"            if(root->right==NULL)",
			"            {",
			"                node *temp;",
			"                temp=root->left;",
			"                while(temp->right!=NULL){",
			"                    temp=temp->right;",
			"                }",
			"                x=temp->data;",
			"                root->data=x;",
			"                root->left=delete_node(root->left,x);",
			"            }",
			"        }",
			"        return root;",
			"    }",
			"",
			"    void delete_node(int x){",
			"        root=delete_node(root,x);",
			"    }",
			"",
			"};",
			"$2"
		],
		"description": "Binary Search Tree implementation"
	}
}