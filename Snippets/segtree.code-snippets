{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"Segment Tree": {
		"scope": "cpp",
		"prefix": "segtree",
		"body": [
			"struct segtree",
			"{",
			"   // data- structure",
			"   ll size;",
			"   vector<ll> seg;",
			"   // constructor",
			"   segtree(ll n)",
			"   {",
			"       size = 1;",
			"       while(size < n)",
			"       {",
			"         size *= 2;",
			"       }",
			"      // assign is used to assign a single value or to the whole of the array",
			"      // syntax: assign(size, value)",
			"      seg.assign(2 * size,0);",
			"   }",
			"     //build the segment tree in O(n) time complexity as every node is visited exactly once",
			"      void build(vector<ll>&a, ll x, ll lx, ll rx){",
			"     if(rx-lx==1){",
			"     // to check if it a valid position of the vector array",
			"     if(lx<a.size()){",
			"       seg[x]=a[lx];",
			"     }",
			"     return ;",
			"   }",
			"    ll m=(lx+rx)/2;",
			"     build(a,2*x+1, lx, m);",
			"     build(a,2*x+2, m,rx);",
			"     seg[x]=seg[2*x+1]+seg[2*x+2];",
			"     }",
			"     void build(vector<ll>&a)",
			"     {",
			"         build(a,0,0,size);",
			"     }",
			"      // set the segtree tree",
			"      // set index i with the value time complexity: O(logN)",
			"     void set(ll i, ll v, ll x, ll lx, ll rx)",
			"     {",
			"     if (rx - lx == 1)",
			"     {",
			"        seg[x] = v;",
			"        return ;",
			"      }",
			"     ll m = (lx + rx) / 2;",
			"     if (i < m)",
			"       set(i, v,2 * x + 1, lx, m);",
			"     else",
			"       set(i, v, 2 * x + 2, m, rx);",
			"     seg[x]=seg[2*x+1]+seg[2*x+2];",
			"     }",
			"     void set(ll i, ll val)",
			"     {",
			"         set(i, val, 0,0, size);",
			"     }",
			"     ll sum(ll l,ll r, ll x, ll lx, ll rx){",
			"     if(lx>=r ||  rx<=l)",
			"       return 0;",
			"     if(lx>=l && rx<=r)  return seg[x];",
			"     ll s1,s2;",
			"     ll m=(lx+rx)/2;",
			"     s1=sum(l,r,2*x+1,lx,m);",
			"     s2=sum(l,r,2*x+2,m,rx);",
			"     return s1+s2;",
			"     }",
			"     ll sum(ll l, ll r){",
			"     return sum(l,r,0,0,size);",
			"     }",
			"};",
		],
		"description": "Segment Tree implementation"
	}
}